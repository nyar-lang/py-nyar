class Point[T](x: T, y: T)

###^
Note that private fields are not inherited,

only public interfaces are automatically inherited
###
class Ellipse[T]: Shape {
    #^ define a field, with default initialization
    _center: (T, T);
    _axis: (T, T) = (T::ONE + T.ONE, T.ONE);
    extends(center) {
    get() {
    Point(_center.0, _center.1)
    }
    set(v: Point[T]) {
    _axis.0 = (v.x, v.y)
    }
    }
    extends(major_axis): Point[T] {
    get: _axis.0,
    set: _axis.0 = value
    }
    extends(minor_axis, _axis.1, get, set);
}

class Circle[T]: Ellipse[T] {
    #^ Declare field and getter methods at the same time
    get center: Point[T];
    _radius: T = T.ONE;
    #^ Subclasses need to implement all public interfaces of the superclass
    extends(radius, _radius, get, set)
    extends(major_axis, _radius, get, set)
    extends(minor_axis, _radius, get, set)
}

#^ define the setter with complete standard form
extends[T] Circle[T] {
    def set center(v: (T, T)) {
        self.center = Point(v.0, v.1)
    }
}


class Const[]
{
    1: 1 = 1
};

let mut exprs = ASTSequence()

for operations |op| {
switch (op) {
.Sum => acc += num,
.Mul => acc *= num,
.Sub => acc -= num,
}
}
return acc;



/// Compares two slices and returns whether they are equal.pub fn eql (comptime T: type, a: []const T, b: []const T) bool {
if (a.len != b.len) return false;
for (a) |item, index| {
if (b [index] != item) return false;
}
return true;
}

first_or_default:: (usize) ([])
